#' @title Processing Hi-C paired-end fastq files in R
#'
#' @name HiCool
#' @aliases importHiCoolFolder
#' @aliases getHiCoolArgs
#' @aliases getHicStats
#' 
#' @description 
#' `HiCool::HiCool()` automatically processes paired-end HiC sequencing files 
#' by performing the following steps: 
#' 
#' 1. Automatically setting up an appropriate conda environment using basilisk;  
#' 2. Mapping the reads to the provided genome reference using hicstuff;  
#' 4. Filtering the resulting pairs file to remove unwanted chromosomes (e.g. chrM);  
#' 3. Binning the filtered pairs into a cool file at a chosen resolution;  
#' 5. Generating a multi-resolution mcool file;  
#' 6. Normalizing matrices at each resolution by iterative corretion using cooler.
#' 
#' @section HiCool utils:
#' - `importHiCoolFolder(folder, hash)` automatically finds the different processed files 
#' associated with a specific HiCool::HiCool() processing hash ID.  
#' - getHiCoolArgs() parses the log file generated by HiCool::HiCool() during 
#' processing to recover which arguments were used.  
#' - getHicStats() parses the log file generated by HiCool::HiCool() during 
#' processing to recover pre-computed stats about pair numbers, filtering 
#' thresholds, etc.  
#' 
#' @param log Path to log file generated by hicstuff/hicool
#' @param r1 Path to fastq file (R1 read)
#' @param r2 Path to fastq file (R2 read)
#' @param genome Genome used to map the reads on, provided either 
#'   as a fasta file (in which case the bowtie2 index will be automatically 
#'   generated), or as a prefix to a bowtie2 index (e.g. `mm10` for 
#'   `mm10.*.bt2` files). Genome can also be a unique ID for the following 
#'   references: `hg38`, `mm10`, `dm6`, `R64-1-1`, `GRZc10`, `WBcel235`, 
#'   `Galgal4`.
#' @param resolutions Resolutions used to bin the final mcool file 
#'   (Default: "1000,2000,4000,8000,16000")
#' @param restriction Restriction enzyme(s) used in HiC (Default: "DpnII,HinfI")
#' @param iterative Should the read mapping be performed iteratively? 
#'   (Default: TRUE)
#' @param filter Should read pairs be filtered (using filtering approach 
#'   described in Cournac et al., BMC Genomics 2012)? (Default: TRUE)
#' @param balancing_args Balancing arguments for cooler (Default: 
#' " --cis-only --min-nnz 3 --mad-max 7 ")
#' @param threads Number of CPUs used for parallelization. (Default: 1)
#' @param exclude_chr Chromosomes excluded from the final .mcool file. This will 
#'   not affect the pairs file. (Default: "Mito|chrM|MT")
#' @param output Path to output directory where processed files will 
#'   be created. (Default: `./HiCool`)
#' @param keep_bam Should the bam files be kept? (Default: FALSE)
#' @param build_report Should an automated report be computed? (Default: TRUE)
#' @param scratch Path to temporary directory where processing will take place. 
#'   (Default: `tempdir()`)
#' @param output Output folder used by HiCool.
#' @param hash Unique 6-letter ID used to identify files from a specific 
#'   HiCool processing run.
#' @param resolution Resolution used to import the mcool file
#' 
#' @return A `CoolFile` object with prefilled `pairsFile` and `metadata` slots.
#' 
#' @importClassesFrom HiCExperiment CoolFile
#' @import HiCExperiment
#' @importFrom HiCExperiment CoolFile
#' @importFrom stringr str_replace_all
#' @importFrom basilisk basiliskStart
#' @importFrom basilisk basiliskStop
#' @importFrom basilisk basiliskRun
#' @importFrom utils read.delim
#' @export
#' 
#' @examples 
#' r1 <- HiContactsData::HiContactsData(sample = 'yeast_wt', format = 'fastq_R1')
#' r2 <- HiContactsData::HiContactsData(sample = 'yeast_wt', format = 'fastq_R2')
#' hcf <- HiCool(r1, r2, genome = 'R64-1-1', output = './HiCool/')
#' hcf
#' getHiCoolArgs(S4Vectors::metadata(hcf)$log)
#' getHicStats(S4Vectors::metadata(hcf)$log)
#' readLines(S4Vectors::metadata(hcf)$log)
NULL

#' @rdname HiCool
#' @export 

HiCool <- function(
    r1, 
    r2, 
    genome, 
    restriction = 'DpnII,HinfI', 
    resolutions = NULL, 
    iterative = TRUE, 
    filter = TRUE, 
    balancing_args = " --cis-only --min-nnz 3 --mad-max 7 ", 
    threads = 1L, 
    exclude_chr = 'Mito|chrM|MT', 
    output = 'HiCool', 
    keep_bam = FALSE, 
    build_report = TRUE, 
    scratch = tempdir()  
)
{
    r1 <- normalizePath(r1)
    r2 <- normalizePath(r2)
    output <- normalizePath(output, mustWork = FALSE)
    genome <- .checkGenome(genome)

    proc <- basilisk::basiliskStart(env_HiCool)
    on.exit(basilisk::basiliskStop(proc))
    on.exit(unlink(scratch), add = TRUE)
    hash <- basilisk::basiliskRun(
        env = env_HiCool, 
        fun = .processFastq,
        r1 = r1, 
        r2 = r2, 
        genome = genome, 
        resolutions = resolutions, 
        restriction = restriction, 
        iterative = iterative, 
        filter = filter, 
        balancing_args = balancing_args, 
        threads = as.integer(threads), 
        output = output, 
        exclude_chr = exclude_chr, 
        keep_bam = keep_bam, 
        scratch = scratch  
    )
    hcf <- importHiCoolFolder(output, hash)
    message("HiCool :: .fastq to .mcool processing done!")
    message("HiCool :: Check ", output, "folder to find the generated files")
    if (build_report) {
        message("HiCool :: Generating HiCool report. This might take a while.")
        HiCReport(hcf)
    }
    message("HiCool :: All processing successfully achieved. Congrats!")

    return(hcf)
}

.processFastq <- function(
    r1, 
    r2, 
    genome, 
    resolutions, 
    restriction, 
    iterative, 
    filter, 
    balancing_args, 
    threads, 
    output, 
    exclude_chr, 
    keep_bam, 
    scratch  
) {

    ###############################################
    ## -------- Import python libraries -------- ##
    ###############################################

    hs <- reticulate::import("hicstuff")
    cooler <- reticulate::import("cooler")

    ##############################################
    ## ----------- Define variables ----------- ##
    ##############################################

    hash <- paste0(sample(c(LETTERS, 0:9), 6, replace = TRUE), collapse = '')
    tmp_folder <- file.path(scratch, hash)
    message("HiCool :: Initiating processing of fastq files [tmp folder: ", tmp_folder, "]...")
    prefix <- paste0(
        gsub('[._][rR][12].*', '', basename(r1)), 
        '^mapped-', gsub('.fa$', '', basename(genome)), 
        '^', hash
    )
    frags <- file.path(tmp_folder, paste0(prefix, '.frags.tsv'))
    chroms <- file.path(tmp_folder, paste0(prefix, '.chr.tsv'))
    filtered_chroms <- file.path(tmp_folder, paste0(prefix, '.chr_filtered.tsv'))
    contact_map <- file.path(tmp_folder, paste0(prefix, '.cool'))
    rebinned_prefix <- file.path(tmp_folder, paste0(prefix, '_res0'))
    contact_map_rebinned <- file.path(tmp_folder, paste0(prefix, '_res0.cool'))
    contact_map_filtered <- file.path(tmp_folder, paste0(prefix, '_res0_filtered.cool'))
    contact_map_mcool <- file.path(tmp_folder, paste0(prefix, '_res0.mcool'))
    sinked_log <- file.path(tmp_folder, paste0(prefix, '.Rlog'))
    dir.create(tmp_folder, showWarnings = FALSE, recursive = TRUE)

    ###############################################
    ## -------- Map reads with hicstuff -------- ##
    ###############################################

    message("HiCool :: Mapping fastq files...")
    hs$pipeline$full_pipeline(
        input1 = r1, 
        input2 = r2, 
        genome = genome, 
        enzyme = restriction, 
        filter_events = filter, 
        force = TRUE, 
        mapping = ifelse(iterative, "iterative", "normal"),
        mat_fmt = "cool",
        # mat_fmt = "graal",
        no_cleanup = TRUE,
        out_dir = tmp_folder, 
        pcr_duplicates = TRUE, 
        plot = TRUE, 
        prefix = prefix, 
        threads = threads,
        distance_law = TRUE
    ) |> reticulate::py_capture_output() |> write(sinked_log)
    log_file <- list.files(tmp_folder, pattern = paste0(hash, '.hicstuff_'), full.names = TRUE)
    writeLines(c(
        paste0("HiCool working directory ::: ", getwd()),
        paste0("HiCool argument ::: r1: ", r1),
        paste0("HiCool argument ::: r2: ", r2),
        paste0("HiCool argument ::: genome: ", genome),
        paste0("HiCool argument ::: resolutions: ", resolutions),
        paste0("HiCool argument ::: restriction: ", restriction),
        paste0("HiCool argument ::: iterative: ", iterative),
        paste0("HiCool argument ::: filter: ", filter),
        paste0("HiCool argument ::: balancing_args: ", balancing_args),
        paste0("HiCool argument ::: threads: ", threads),
        paste0("HiCool argument ::: output: ", output),
        paste0("HiCool argument ::: exclude_chr: ", exclude_chr),
        paste0("HiCool argument ::: keep_bam: ", keep_bam),
        paste0("HiCool argument ::: scratch: ", scratch),
        "----------------",
        readLines(log_file)
    ), log_file)

    ###########################################################################
    ## ---- Automatically deduce appropriate resolutions if unspecified ---- ##
    ###########################################################################

    chrs <- utils::read.delim(file.path(tmp_folder, paste0(prefix, '.chr.tsv')), sep = '\t') 
    if (is.null(resolutions)) { 
        list_resolutions <- list(
            c(100, 200, 400, 800, 1600),
            c(1000, 2000, 4000, 8000, 16000),
            c(4000, 8000, 16000, 32000, 64000, 128000, 256000, 512000),
            c(10000, 20000, 40000, 80000, 160000, 320000, 640000, 1280000, 2560000)
        )
        tot_length <- sum(chrs$length)
        resolutions_idx <- ifelse(
            tot_length < 16000, 1, ifelse(
            tot_length >= 16000 & tot_length < 100000000, 2, ifelse(
            tot_length >= 100000000 & tot_length < 1000000000, 3,
            tot_length >= 1000000000 ~ 4
        )))
        first_res <- list_resolutions[[resolutions_idx]][1]
        message("HiCool :: Best-suited minimum resolution automatically inferred: ", first_res)
        resolutions <- paste(list_resolutions[[resolutions_idx]], collapse = ',')
    }
    else {
        first_res <- as.integer(gsub(',.*', '', resolutions))
    }

    ############################################################
    ## -------- Exclude unwanted chr. from cool file -------- ##
    ############################################################

    excludable_chrs <- grep(exclude_chr, chrs$contig, value = TRUE)
    if (length(excludable_chrs)) {
        message("HiCool :: Remove unwanted chromosomes...")
        chr <- readLines(file.path(tmp_folder, paste0(prefix, '.chr.tsv'))) 
        chr <- grep(exclude_chr, chr, invert = TRUE, value = TRUE)
        chr <- grep('contig', chr, invert = TRUE, value = TRUE)
        writeLines(chr, filtered_chroms)
    }
    else {
        file.copy(file.path(tmp_folder, paste0(prefix, '.chr.tsv')), filtered_chroms)
    }

    ############################################################
    ## --------------- Parse pairs into cool ---------------- ##
    ############################################################

    cooler$cli$cload$pairs$callback(
        bins = paste0(filtered_chroms, ":", first_res), 
        pairs_path = file.path(tmp_folder, 'tmp',  paste0(prefix, '.valid_idx_pcrfree.pairs')), 
        cool_path = contact_map_filtered, 
        metadata = NULL, 
        assembly = NULL, 
        chunksize = 20e6L, 
        zero_based = TRUE, 
        comment_char = "#", 
        input_copy_status = NULL, 
        no_symmetric_upper = FALSE, 
        field = "", 
        temp_dir = file.path(tmp_folder, 'tmp'), 
        no_delete_temp = FALSE, 
        max_merge = 200L, 
        storage_options = NULL, 
        chrom1 = 2L, 
        pos1 = 3L, 
        chrom2 = 4L, 
        pos2 = 5L 
    ) |> reticulate::py_capture_output() |> write(sinked_log, append = TRUE)

    ########################################################################
    ## -------- Generate a multi-resolution, balanced mcool file -------- ##
    ########################################################################

    message("HiCool :: Generating multi-resolution .mcool file...")
    cooler$zoomify_cooler(
        base_uris = contact_map_filtered, 
        outfile = contact_map_mcool, 
        resolutions = strsplit(resolutions, ',')[[1]] |> as.integer(), 
        chunksize = 10000000L, 
        nproc = threads, 
        columns = NULL, 
        dtypes = NULL, 
        agg = NULL
    ) |> reticulate::py_capture_output() |> write(sinked_log, append = TRUE)
    message("HiCool :: Balancing .mcool file...")
    cooler$cli$zoomify$invoke_balance(
        args = paste0("--nproc ", threads, balancing_args), 
        resolutions = strsplit(resolutions, ',')[[1]] |> as.integer(), 
        outfile = contact_map_mcool  
    ) |> reticulate::py_capture_output() |> write(sinked_log, append = TRUE)

    ##########################################
    ## -------- Tidy-up everything -------- ##
    ##########################################

    message("HiCool :: Tidying up everything for you...")

    # Matrices
    dir.create(file.path(output, 'matrices'), showWarnings = FALSE, recursive = TRUE)
    file.copy(
        contact_map_mcool, 
        file.path(output, 'matrices', paste0(prefix, '.mcool'))
    )

    # Bam
    if (keep_bam) {
        dir.create(file.path(output, 'bam'), showWarnings = FALSE, recursive = TRUE)
        file.copy(
            file.path(tmp_folder, 'tmp', paste0(prefix, '.for.bam')), 
            file.path(output, 'bam', paste0(prefix, '.fwd.bam'))
        )
        file.copy(
            file.path(tmp_folder, 'tmp', paste0(prefix, '.rev.bam')), 
            file.path(output, 'bam', paste0(prefix, '.rev.bam'))
        )
    }

    # Pairs
    dir.create(file.path(output, 'pairs'), showWarnings = FALSE, recursive = TRUE)
    file.copy(
        list.files(tmp_folder, pattern = paste0(hash, '.valid_idx_pcrfree.pairs'), recursive = TRUE, full.names = TRUE), 
        file.path(output, 'pairs', paste0(prefix, '.pairs'))
    )

    # Plots
    dir.create(file.path(output, 'plots'), showWarnings = FALSE, recursive = TRUE)
    file.copy(
        list.files(tmp_folder, pattern = paste0(hash, '_event_distance.pdf'), recursive = TRUE, full.names = TRUE), 
        file.path(output, 'plots', paste0(prefix, '_event_distance.pdf'))
    )
    file.copy(
        list.files(tmp_folder, pattern = paste0(hash, '_event_distribution.pdf'), recursive = TRUE, full.names = TRUE), 
        file.path(output, 'plots', paste0(prefix, '_event_distribution.pdf'))
    )

    # Log
    dir.create(file.path(output, 'logs'), showWarnings = FALSE, recursive = TRUE)
    file.copy(
        log_file,
        file.path(output, 'logs', paste0(prefix, '.log'))
    )

    return(hash)
}
